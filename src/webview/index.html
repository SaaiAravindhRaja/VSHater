<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VSHater - Brainrot Detection</title>
    <style id="styles"></style>
</head>
<body>
    <div class="container">
        <!-- Action Picker -->
        <div class="picker-overlay" id="pickerOverlay">
            <div class="picker-content">
                <h1>PICK YOUR BRAINROT</h1>
                <p>Select an action to test:</p>

                <div class="picker-section">
                    <h3>Body</h3>
                    <div class="picker-buttons">
                        <button class="picker-btn" onclick="selectAction('dab')">DAB</button>
                    </div>
                </div>

                <div class="picker-section">
                    <h3>Movement</h3>
                    <div class="picker-buttons">
                        <button class="picker-btn" onclick="selectAction('67hands')">67 HANDS</button>
                        <button class="picker-btn" onclick="selectAction('fanum')">FANUM TAX</button>
                    </div>
                </div>

                <div class="picker-section">
                    <h3>Face</h3>
                    <div class="picker-buttons">
                        <button class="picker-btn" onclick="selectAction('tongue')">TONGUE</button>
                    </div>
                </div>

                <div class="picker-section">
                    <h3>Meme</h3>
                    <div class="picker-buttons">
                        <button class="picker-btn" onclick="selectAction('monkeythink')">MONKEY THINK</button>
                    </div>
                </div>

                <button class="picker-btn random" onclick="selectAction('random')">RANDOM</button>
            </div>
        </div>

        <div class="camera-wrapper">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
        </div>

        <div class="overlay" id="detectionOverlay" style="display: none;">
            <div class="instruction">
                <h1 id="actionTitle">LOADING...</h1>
                <p id="actionDesc">Get ready!</p>
            </div>
            <div class="match-meter">
                <div class="meter-label">Match</div>
                <div class="meter-bar"><div class="meter-fill" id="meterFill"></div></div>
                <div class="meter-value" id="meterValue">0%</div>
            </div>
            <div class="status" id="status">Initializing...</div>
        </div>

        <div class="success-overlay" id="successOverlay">
            <div class="success-content">
                <h1 id="successTitle">SUCCESS!</h1>
                <p>You absolute legend. Code unlocked.</p>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js"></script>

    <script>
        document.getElementById('styles').textContent = `
            @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: #0a0a0f; color: white; overflow: hidden; height: 100vh; width: 100vw; }
            .container { position: relative; width: 100%; height: 100%; }
            .camera-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
            #video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); filter: brightness(0.95) contrast(1.05); }
            #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }

            .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; padding: 40px; pointer-events: none; }
            .instruction { text-align: center; }
            .instruction h1 { font-size: 3.5rem; font-weight: 900; background: linear-gradient(135deg, #fff 0%, #a78bfa 50%, #818cf8 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-shadow: none; animation: glow 2s ease-in-out infinite; letter-spacing: -1px; }
            .instruction p { font-size: 1.1rem; opacity: 0.8; margin-top: 12px; font-weight: 500; color: rgba(255,255,255,0.9); }
            @keyframes glow { 0%, 100% { filter: drop-shadow(0 0 20px rgba(139, 92, 246, 0.5)); } 50% { filter: drop-shadow(0 0 40px rgba(139, 92, 246, 0.8)); } }

            .match-meter { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 16px; background: rgba(15, 15, 25, 0.8); padding: 16px 28px; border-radius: 20px; backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.1); box-shadow: 0 8px 32px rgba(0,0,0,0.4); }
            .meter-label { font-weight: 600; font-size: 0.9rem; color: rgba(255,255,255,0.7); text-transform: uppercase; letter-spacing: 1px; }
            .meter-bar { width: 220px; height: 12px; background: rgba(255,255,255,0.1); border-radius: 6px; overflow: hidden; }
            .meter-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #f472b6, #c084fc, #818cf8); border-radius: 6px; transition: width 0.15s ease-out; box-shadow: 0 0 20px rgba(192, 132, 252, 0.5); }
            .meter-fill.success { background: linear-gradient(90deg, #34d399, #10b981); box-shadow: 0 0 25px rgba(16, 185, 129, 0.6); }
            .meter-value { font-weight: 700; min-width: 50px; font-size: 1.1rem; color: #fff; }

            .status { position: fixed; top: 24px; right: 24px; background: rgba(15, 15, 25, 0.7); padding: 10px 20px; border-radius: 12px; font-size: 0.85rem; font-weight: 500; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.08); }

            .success-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, rgba(16, 185, 129, 0.95) 0%, rgba(5, 150, 105, 0.95) 100%); display: none; justify-content: center; align-items: center; z-index: 100; }
            .success-overlay.show { display: flex; animation: successFade 0.4s cubic-bezier(0.16, 1, 0.3, 1); }
            @keyframes successFade { from { opacity: 0; transform: scale(1.1); } to { opacity: 1; transform: scale(1); } }
            .success-content { text-align: center; }
            .success-content h1 { font-size: 4rem; font-weight: 900; margin-bottom: 16px; animation: successBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); letter-spacing: -2px; }
            .success-content p { font-size: 1.4rem; opacity: 0.95; font-weight: 500; }
            @keyframes successBounce { 0% { transform: scale(0) rotate(-10deg); opacity: 0; } 60% { transform: scale(1.1) rotate(2deg); } 100% { transform: scale(1) rotate(0deg); opacity: 1; } }

            .picker-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%); display: flex; justify-content: center; align-items: center; z-index: 200; overflow-y: auto; padding: 40px 20px; }
            .picker-overlay.hidden { display: none; }
            .picker-content { text-align: center; max-width: 600px; }
            .picker-content h1 { font-size: 2.8rem; margin-bottom: 8px; background: linear-gradient(135deg, #f472b6 0%, #c084fc 50%, #818cf8 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 900; letter-spacing: -1px; }
            .picker-content > p { font-size: 1rem; opacity: 0.5; margin-bottom: 32px; font-weight: 500; }

            .picker-section { margin-bottom: 24px; }
            .picker-section h3 { font-size: 0.75rem; opacity: 0.4; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 3px; font-weight: 600; }
            .picker-buttons { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }

            .picker-btn { padding: 16px 28px; font-size: 0.95rem; font-weight: 700; border: none; border-radius: 14px; cursor: pointer; background: rgba(255,255,255,0.08); color: white; transition: all 0.25s cubic-bezier(0.16, 1, 0.3, 1); min-width: 130px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); letter-spacing: 0.5px; }
            .picker-btn:hover { transform: translateY(-3px) scale(1.02); background: rgba(255,255,255,0.15); box-shadow: 0 12px 40px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.15); }
            .picker-btn:active { transform: translateY(-1px) scale(0.98); }

            .picker-btn.random { background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%); border: none; min-width: 220px; margin-top: 32px; padding: 20px 40px; font-size: 1.1rem; box-shadow: 0 8px 30px rgba(99, 102, 241, 0.4); }
            .picker-btn.random:hover { transform: translateY(-4px) scale(1.02); box-shadow: 0 16px 50px rgba(99, 102, 241, 0.5); }

            .confetti { position: fixed; width: 10px; height: 10px; pointer-events: none; z-index: 101; animation: confettiFall 3s linear forwards; }
            @keyframes confettiFall { 0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        `;

        // ========== 5 FINAL ACTIONS ==========
        const ACTIONS = {
            // Body Pose
            dab: { title: "DAB!", desc: "One arm up, head toward elbow", success: "DAB DETECTED!", needsPose: true, needsFace: false },
            // Movement
            '67hands': { title: "67 67 67!", desc: "Wave both hands up and down rapidly", success: "67 DETECTED!", needsPose: true, needsFace: false },
            fanum: { title: "FANUM TAX!", desc: "Reach forward like you're stealing food", success: "TAXED!", needsPose: true, needsFace: false },
            // Face
            tongue: { title: "TONGUE OUT!", desc: "Open mouth wide and shake your head", success: "TONGUE DETECTED!", needsPose: false, needsFace: true },
            // Combined (Pose + Face)
            monkeythink: { title: "MONKEY THINK!", desc: "Finger on chin, look up and think", success: "BIG BRAIN!", needsPose: true, needsFace: true }
        };

        const urlParams = new URLSearchParams(window.location.search);
        let currentAction = urlParams.get('action');
        let actionConfig = currentAction ? (ACTIONS[currentAction] || ACTIONS.dab) : null;
        const showPicker = !currentAction;

        function selectAction(action) {
            if (action === 'random') {
                const keys = Object.keys(ACTIONS);
                action = keys[Math.floor(Math.random() * keys.length)];
            }
            currentAction = action;
            actionConfig = ACTIONS[action];
            document.getElementById('pickerOverlay').classList.add('hidden');
            document.getElementById('detectionOverlay').style.display = 'flex';
            startDetection();
        }

        async function startDetection() {
            try {
                setActionUI();
                updateStatus('Loading MediaPipe...');
                await Detector.init();
                await Detector.start();
            } catch (error) {
                console.error('Error:', error);
                updateStatus('Error: ' + error.message);
            }
        }

        const L = { NOSE: 0, LEFT_EYE: 2, RIGHT_EYE: 5, LEFT_SHOULDER: 11, RIGHT_SHOULDER: 12, LEFT_ELBOW: 13, RIGHT_ELBOW: 14, LEFT_WRIST: 15, RIGHT_WRIST: 16, LEFT_HIP: 23, RIGHT_HIP: 24 };

        function calcAngle(a, b, c) {
            const rad = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let ang = Math.abs(rad * 180 / Math.PI);
            return ang > 180 ? 360 - ang : ang;
        }

        function dist(a, b) { return Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2); }

        function createMatcher(detectFn, threshold = 0.70, holdMs = 600) {
            return {
                MATCH_THRESHOLD: threshold, HOLD_TIME_MS: holdMs,
                matchStartTime: null, isMatched: false,
                detect: detectFn,
                checkHold(pct) {
                    if (pct >= this.MATCH_THRESHOLD) {
                        if (!this.matchStartTime) this.matchStartTime = Date.now();
                        if (Date.now() - this.matchStartTime >= this.HOLD_TIME_MS && !this.isMatched) {
                            this.isMatched = true; return true;
                        }
                    } else { this.matchStartTime = null; }
                    return false;
                },
                reset() { this.matchStartTime = null; this.isMatched = false; }
            };
        }

        // ========== BODY POSE MATCHERS ==========
        const DabMatcher = createMatcher(function(lm) {
            if (!lm || lm.length < 17) return 0;
            const isRaised = (s,e,w) => e.y < s.y && w.y < e.y;
            const isExtended = (s,e,w) => calcAngle(s,e,w) > 130; // Relaxed from 150
            const leftR = isRaised(lm[L.LEFT_SHOULDER], lm[L.LEFT_ELBOW], lm[L.LEFT_WRIST]);
            const rightR = isRaised(lm[L.RIGHT_SHOULDER], lm[L.RIGHT_ELBOW], lm[L.RIGHT_WRIST]);
            const leftE = isExtended(lm[L.LEFT_SHOULDER], lm[L.LEFT_ELBOW], lm[L.LEFT_WRIST]);
            const rightE = isExtended(lm[L.RIGHT_SHOULDER], lm[L.RIGHT_ELBOW], lm[L.RIGHT_WRIST]);
            let score = 0;
            if ((rightR && leftE) || (leftR && rightE)) {
                score = 0.6; // Increased base score
                const elbow = rightR ? lm[L.RIGHT_ELBOW] : lm[L.LEFT_ELBOW];
                const headDist = dist(lm[L.NOSE], elbow);
                score += Math.max(0, 0.4 * (1 - headDist / 0.5)); // Much more relaxed: 0.5 instead of 0.25
            }
            return Math.min(1, score);
        });

        // ========== MOVEMENT MATCHERS ==========
        const SixtySevenMatcher = (() => {
            const m = createMatcher(function(lm) {
                if (!lm || lm.length < 17) return 0;
                this.leftHist = this.leftHist || [];
                this.rightHist = this.rightHist || [];
                this.leftHist.push(lm[L.LEFT_WRIST].y);
                this.rightHist.push(lm[L.RIGHT_WRIST].y);
                if (this.leftHist.length > 30) this.leftHist.shift();
                if (this.rightHist.length > 30) this.rightHist.shift();
                if (this.leftHist.length < 15) return 0;

                const countChanges = (h) => {
                    let c = 0, last = 0;
                    for (let i = 1; i < h.length; i++) {
                        const d = h[i] - h[i-1];
                        if (Math.abs(d) > 0.015) {
                            const dir = d > 0 ? 1 : -1;
                            if (last !== 0 && dir !== last) c++;
                            last = dir;
                        }
                    }
                    return c;
                };
                const getRange = (h) => Math.max(...h) - Math.min(...h);

                const lc = countChanges(this.leftHist), rc = countChanges(this.rightHist);
                const lr = getRange(this.leftHist), rr = getRange(this.rightHist);

                // FIXED: Require amplitude (actual movement range)
                if (lr < 0.08 || rr < 0.08) return 0;

                const changeScore = (Math.min(1, lc/5) + Math.min(1, rc/5)) / 2;
                const rangeScore = (Math.min(1, lr/0.15) + Math.min(1, rr/0.15)) / 2;
                return changeScore * 0.6 + rangeScore * 0.4;
            });
            m.leftHist = []; m.rightHist = [];
            const origReset = m.reset;
            m.reset = function() { origReset.call(this); this.leftHist = []; this.rightHist = []; };
            return m;
        })();

        const FanumMatcher = (() => {
            const m = createMatcher(function(lm) {
                if (!lm || lm.length < 17) return 0;
                this.hist = this.hist || [];
                const lw = lm[L.LEFT_WRIST], rw = lm[L.RIGHT_WRIST];
                const ls = lm[L.LEFT_SHOULDER], rs = lm[L.RIGHT_SHOULDER];
                const nose = lm[L.NOSE];

                // Track hand positions over time
                const avgHandY = (lw.y + rw.y) / 2;
                this.hist.push(avgHandY);
                if (this.hist.length > 20) this.hist.shift();

                // Hands must be in front of body (between shoulders, below face)
                const handsCentered = Math.abs((lw.x + rw.x) / 2 - (ls.x + rs.x) / 2) < 0.2;
                const handsLower = avgHandY > nose.y;

                // Hands moving DOWN (toward camera = grabbing motion)
                let movingForward = false;
                if (this.hist.length >= 10) {
                    const recent = this.hist.slice(-5);
                    const older = this.hist.slice(-10, -5);
                    const recentAvg = recent.reduce((a,b) => a+b, 0) / recent.length;
                    const olderAvg = older.reduce((a,b) => a+b, 0) / older.length;
                    movingForward = recentAvg > olderAvg + 0.03; // Hands moved down significantly
                }

                let score = 0;
                if (handsCentered) score += 0.3;
                if (handsLower) score += 0.3;
                if (movingForward) score += 0.4;
                return score;
            }, 0.70, 800); // Longer hold time: 800ms
            m.hist = [];
            m.reset = function() { this.matchStartTime = null; this.isMatched = false; this.hist = []; };
            return m;
        })();

        // ========== FACE MATCHERS ==========
        const TongueMatcher = (() => {
            const m = createMatcher(function(fl) {
                if (!fl || fl.length < 400) return 0;
                this.hist = this.hist || [];
                const ul = fl[13], ll = fl[14], lm = fl[78], rm = fl[308];
                const open = Math.abs(ul.y - ll.y) / (Math.abs(lm.x - rm.x) + 0.001);
                this.hist.push(fl[1].x);
                if (this.hist.length > 20) this.hist.shift();
                let shake = 0;
                if (this.hist.length >= 10) {
                    let last = 0;
                    for (let i = 1; i < this.hist.length; i++) {
                        const d = this.hist[i] - this.hist[i-1];
                        if (Math.abs(d) > 0.005) {
                            const dir = d > 0 ? 1 : -1;
                            if (last !== 0 && dir !== last) shake++;
                            last = dir;
                        }
                    }
                }
                return Math.min(1, open / 0.4) * 0.6 + Math.min(1, shake / 4) * 0.4;
            });
            m.hist = [];
            m.reset = function() { this.matchStartTime = null; this.isMatched = false; this.hist = []; };
            return m;
        })();

        // ========== COMBINED MATCHER ==========
        const MonkeyThinkMatcher = createMatcher(function(lm) {
            if (!lm || lm.length < 17) return 0;
            const lw = lm[L.LEFT_WRIST], rw = lm[L.RIGHT_WRIST];
            const nose = lm[L.NOSE];

            // Hand near chin/face area
            const leftNearChin = dist(lw, nose) < 0.2 && lw.y > nose.y;
            const rightNearChin = dist(rw, nose) < 0.2 && rw.y > nose.y;
            const handNearChin = leftNearChin || rightNearChin;

            // Looking up (nose higher than shoulders midpoint)
            const shoulderMidY = (lm[L.LEFT_SHOULDER].y + lm[L.RIGHT_SHOULDER].y) / 2;
            const lookingUp = nose.y < shoulderMidY - 0.05;

            // Head tilted (use eye positions)
            const leftEye = lm[L.LEFT_EYE], rightEye = lm[L.RIGHT_EYE];
            const eyeMidY = (leftEye.y + rightEye.y) / 2;
            const headTilted = nose.y > eyeMidY + 0.02;

            let score = 0;
            if (handNearChin) score += 0.5;
            if (lookingUp || headTilted) score += 0.5;
            return score;
        });

        function getCurrentMatcher() {
            switch (currentAction) {
                case '67hands': return SixtySevenMatcher;
                case 'fanum': return FanumMatcher;
                case 'tongue': return TongueMatcher;
                case 'monkeythink': return MonkeyThinkMatcher;
                default: return DabMatcher;
            }
        }

        const Detector = {
            pose: null, faceMesh: null, camera: null, isRunning: false,
            video: null, canvas: null, ctx: null,

            async init() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');

                if (actionConfig.needsPose) {
                    this.pose = new Pose({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${f}` });
                    this.pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                    this.pose.onResults(r => this.onPose(r));
                }
                if (actionConfig.needsFace) {
                    this.faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${f}` });
                    this.faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                    this.faceMesh.onResults(r => this.onFace(r));
                }
                this.camera = new Camera(this.video, {
                    onFrame: async () => {
                        if (this.isRunning) {
                            if (this.pose) await this.pose.send({ image: this.video });
                            if (this.faceMesh) await this.faceMesh.send({ image: this.video });
                        }
                    },
                    width: 1280, height: 720
                });
            },

            async start() { this.isRunning = true; await this.camera.start(); updateStatus('Detecting...'); },
            stop() { this.isRunning = false; if (this.camera) this.camera.stop(); },

            onPose(r) {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (r.poseLandmarks) {
                    drawConnectors(this.ctx, r.poseLandmarks, POSE_CONNECTIONS, { color: 'rgba(255,255,255,0.5)', lineWidth: 2 });
                    drawLandmarks(this.ctx, r.poseLandmarks, { color: '#ff6b6b', lineWidth: 1, radius: 3 });
                    const m = getCurrentMatcher(), pct = m.detect(r.poseLandmarks);
                    updateMeter(pct, m.MATCH_THRESHOLD);
                    if (m.checkHold(pct)) onActionDetected();
                }
            },

            onFace(r) {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (r.multiFaceLandmarks && r.multiFaceLandmarks[0]) {
                    drawConnectors(this.ctx, r.multiFaceLandmarks[0], FACEMESH_TESSELATION, { color: 'rgba(255,255,255,0.2)', lineWidth: 1 });
                    const m = getCurrentMatcher(), pct = m.detect(r.multiFaceLandmarks[0]);
                    updateMeter(pct, m.MATCH_THRESHOLD);
                    if (m.checkHold(pct)) onActionDetected();
                }
            }
        };

        function updateMeter(pct, thresh) {
            const fill = document.getElementById('meterFill'), val = document.getElementById('meterValue');
            const p = Math.round(pct * 100);
            fill.style.width = p + '%';
            val.textContent = p + '%';
            fill.classList.toggle('success', pct >= thresh);
        }

        function updateStatus(t) { document.getElementById('status').textContent = t; }

        function setActionUI() {
            document.getElementById('actionTitle').textContent = actionConfig.title;
            document.getElementById('actionDesc').textContent = actionConfig.desc;
            document.getElementById('successTitle').textContent = actionConfig.success;
        }

        function createConfetti() {
            const colors = ['#f472b6', '#c084fc', '#818cf8', '#34d399', '#fbbf24', '#fb7185'];
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
                document.body.appendChild(confetti);
                setTimeout(() => confetti.remove(), 4000);
            }
        }

        function onActionDetected() {
            Detector.stop();
            createConfetti();
            document.getElementById('successOverlay').classList.add('show');
            updateStatus('Success!');
            fetch('/action-detected').then(() => setTimeout(() => window.close(), 2500)).catch(console.error);
        }

        async function main() {
            if (showPicker) {
                document.getElementById('pickerOverlay').classList.remove('hidden');
                document.getElementById('detectionOverlay').style.display = 'none';
            } else {
                document.getElementById('pickerOverlay').classList.add('hidden');
                document.getElementById('detectionOverlay').style.display = 'flex';
                await startDetection();
            }
        }

        main();
    </script>
</body>
</html>
